\documentclass{beamer}

\usepackage{beamerthemesplit}
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}[page number]{}

\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{setspace}
\usepackage{url}

\usepackage{fontspec}
\setmonofont{Latin Modern Mono}
\setsansfont{TeX Gyre Heros}

\lstset{breakatwhitespace=true,
language=C++,
basicstyle=\footnotesize\ttfamily,
keywordstyle=\color{blue}\ttfamily,
stringstyle=\color{red}\ttfamily,
commentstyle=\color{brown}\ttfamily,
morecomment=[l][\color{magenta}]{\#}keepspaces=true,
breaklines=true,
tabsize=3,
showstringspaces=false,
extendedchars=true,
frame=single}

\newcommand*{\vcenteredhbox}[1]{\begingroup
\setbox0=\hbox{#1}\parbox{\wd0}{\box0}\endgroup}

\title{Bio-Formats C++ Conversion}
\author{Roger Leigh}
\date{March 2014\\University of Dundee}

\begin{document}

\begin{frame}[plain]
  \titlepage
  \begin{center}
    \vcenteredhbox{\includegraphics[width=0.25\textwidth]{ome}} \hfill
    \vcenteredhbox{\includegraphics[width=0.2\textwidth]{dundee}}\hfill
    \vcenteredhbox{\includegraphics[width=0.25\textwidth]{wellcome}}
  \end{center}
\end{frame}

\section*{Overview}
\frame{
\frametitle{Overview}
\tableofcontents
}

\section{C++ and Java incompatibility}
\subsection{C++ and Java types}

\begin{frame}[fragile]
  \frametitle{Java types}
  \begin{lstlisting}[language=Java]
int i;
double d;

Pixels pixels = new Pixels();

Pixels[] array = new Pixels[5];
\end{lstlisting}
  \begin{itemize}
  \item Primitive types
  \item Classes, all derived from root \texttt{Object}
  \item No unsigned integer types
  \item Objects are by reference only
  \item Objects and arrays are always allocated with \texttt{new}
  \item Destruction is non-deterministic
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ types}
  \begin{lstlisting}
uint32_t i;
double d;

Pixels         pixels;
Pixels        *pixelsptr1 = new Pixels();
const Pixels  *pixelsptr2 = &pixels;
Pixels&        pixelsref(pixels);

Pixels array[5];
\end{lstlisting}
  \begin{itemize}
  \item Primitive types, including unsigned, of standard sizes
  \item Classes have no common root
  \item All types may be instances, pointers or references
  \item Pointers and references may refer to \texttt{const} type
  \item Pointers may be \texttt{const}
  \item Destruction is deterministic
  \end{itemize}
\end{frame}

\subsection{Reference handling}

\begin{frame}[fragile]
  \frametitle{C++ pointers: pitfalls of “dumb” pointers}
  \begin{lstlisting}
{
  Image *i = new Image(filename);

  i->read_plane(); // throws exception

  // Memory leaked here
  // Memory not freed when pointer i goes out of scope
}
\end{lstlisting}
  \begin{itemize}
    \item \texttt{new} and \texttt{delete} must always be paired
    \item Requires manual management of ownership and lifetime
    \item Bare pointers are not exception-safe
    \item Need to clean up for every exit point in a function
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ pointers: \texttt{std::shared\_ptr} as a “smart” pointer}
  \begin{lstlisting}
{ // Image *i = new Image(filename);
  std::shared_ptr<Image> i(std::make_shared<Image>(filename));

  i->read_plane(); // throws exception

  // Memory freed when i's destructor is
  // run at exit of block scope
}

\end{lstlisting}
  \begin{itemize}
    \item \texttt{shared\_ptr} object lifetime manages the resource
    \item May be used as class members; lifetime is tied to class instance
    \item Clean up for all exit points is automatic and safe
    \item Allows ownership transfer and sharing
    \item Allows reference without ownership using \texttt{weak\_ptr}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII: Resource Acquisition Is Initialisation}
    \begin{itemize}
    \item Class is a proxy for a resource
    \item Resource is acquired when object is intialised
    \item Resource is released when object is destroyed
    \item Manage any resource (memory, files, locks)
    \item C++ language and runtime guarantees make resource management
      deterministic and reliable
    \item Safe for use in any scope
    \item Exception safe
    \item Used throughout modern C++ libraries and applications
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ reference variants}
  \begin{lstlisting}[basicstyle=\tiny\ttfamily]
//          Non-constant                              Constant
// -----------------------------       ---------------------------------------
// Pointer
                       Image *i;                               const Image *i;
                Image * const i;                        const Image * const i;

// Reference
                       Image& i;                               const Image& i;

// Shared pointer
       std::shared_ptr<Image> i;               std::shared_ptr<const Image> i;
 const std::shared_ptr<Image> i;         const std::shared_ptr<const Image> i;

// Shared pointer reference
      std::shared_ptr<Image>& i;              std::shared_ptr<const Image>& i;
const std::shared_ptr<Image>& i;        const std::shared_ptr<const Image>& i;

// Weak pointer
         std::weak_ptr<Image> i;                 std::weak_ptr<const Image> i;
   const std::weak_ptr<Image> i;           const std::weak_ptr<const Image> i;

// Weak pointer reference
        std::weak_ptr<Image>& i;                std::weak_ptr<const Image>& i;
  const std::weak_ptr<Image>& i;          const std::weak_ptr<const Image>& i;
\end{lstlisting}
\begin{center}
  Java has one reference type.  Here, we have \textbf{22}…
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ reference usage rationalised}
\begin{block}{Class members}
  \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
Image i;                     // Concrete instance
std::shared_ptr<Image> i;    // Reference
std::weak_ptr<Image> i;      // Weak reference
\end{lstlisting}
\end{block}
\begin{block}{Arguments}
  \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
void read_plane(const Image& image);
void read_plane(const std::shared_ptr<Image>& image);
\end{lstlisting}
\end{block}
\begin{block}{Return}
  \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
                  Image get_image(); // ownership transferred
                 Image& get_image(); // ownership retained
 std::shared_ptr<Image> get_image(); // ownership shared/trans
std::shared_ptr<Image>& get_image(); // ownership shared
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ reference usage rationalised}
  \begin{itemize}
  \item Safety: References can not be \texttt{null}.
  \item Storing polymorphic types requires use of a
    \texttt{shared\_ptr}.
  \item Safety: To avoid cyclic dependencies, use \texttt{weak\_ptr}.
  \item Safety: To allow object destruction while maintaining a safe
    reference, use \texttt{weak\_ptr}.
  \item \texttt{weak\_ptr} is not directly usable.
  \item \texttt{weak\_ptr} is convertible back to \texttt{shared\_ptr}
    for use \emph{if the object is still in existence}.
  \end{itemize}
\end{frame}

\subsection{Additional API concerns}

\begin{frame}[fragile]
  \frametitle{Safe array passing: \texttt{std::array} / \texttt{boost::array}}
  \begin{lstlisting}
class Image
{
  // Unsafe; size unknown
  uint8_t[] getLUT();
       void setLUT(uint8_t[]& lut);

  // Safe; size defined
  typedef std::array<uint8_t, 256> LUT;
  const LUT& getLUT() const;
        void setLUT(const LUT&);
};
\end{lstlisting}
  \begin{itemize}
  \item C (C++) arrays essentially decay to plain pointers
  \item Plain pointers have no associated size information
  \item \texttt{std::array} is an array-like object
  \item \texttt{std::array} size defined in the template
  \item \texttt{std::array} can be passed like any object
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Containers storing different types}
\begin{block}{Types with a common base}
  \begin{lstlisting}
    std::vector<std::shared_ptr<Base> > v;
    v.push_back(std::make_shared<Derived>());
\end{lstlisting}
  \begin{itemize}
  \item Store any type derived from \texttt{Base}
  \end{itemize}
\end{block}
\begin{block}{Java containers can be problematic}
  \begin{itemize}
  \item Java can store root \texttt{Object} in containers
  \item Java can pass and return root \texttt{Object} in methods.
  \item This isn't possible in C++: there is no root object.
  \item An alternative approach is needed.
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Containers storing different types}
\begin{block}{Types with no common base: \texttt{boost::variant}}
  \begin{lstlisting}
    typedef boost::variant<int, std::string> variants;
    std::vector<variants> v;
    v.push_back(43);
    v.push_back("ATTO 647N")
\end{lstlisting}
  \begin{itemize}
  \item Store a set of discriminated types
  \item Used to store original metadata
  \end{itemize}
\end{block}
\begin{block}{Arbitrary types: \texttt{boost::any}}
  \begin{lstlisting}
    std::vector<boost::any> v;
    v.push_back(Anything);
\end{lstlisting}
  \begin{itemize}
  \item Flexible, but need to cast to each type used to extract.
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interfaces}
\begin{block}{Java: Single inheritance, plus interfaces}
\end{block}
\begin{block}{C++: Multiple inheritance}
  \begin{itemize}
  \item Interfaces are classes with:
    \begin{itemize}
      \item No instance variables
      \item Pure virtual methods
      \item \texttt{protected} default constructor
      \item \texttt{public virtual} destructor
      \item Deleted copy constructor and assignment operator
    \end{itemize}
  \item Classes implementing interfaces:
    \begin{itemize}
      \item Use \texttt{public} inheritance for parent class
      \item Use \texttt{virtual public} inheritance for implemented interfaces
      \item \texttt{virtual} destructor
    \end{itemize}
  \end{itemize}
\end{block}
\end{frame}

\section{Bio-Formats}
\subsection{Building and installing}

\begin{frame}[fragile]
  \frametitle{Source layout}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \begin{semiverbatim}\tiny
cpp
├── cmake
├── lib
│   └── ome
│       ├── bioformats
│       │   └── detail
│       ├── compat
│       ├── internal
│       ├── xerces
│       │   └── dom
│       └── xml
│           ├── meta
│           └── model
│               ├── enums
│               └── primitives
└── test
    ├── ome-bioformats
    ├── ome-compat
    ├── ome-internal
    ├── ome-xerces
    └── ome-xml
\end{semiverbatim}
      \end{column}
    \begin{column}{.5\linewidth}
      \begin{block}{compat}
        Compatibility workarounds
      \end{block}
      \begin{block}{internal}
        Private implementation details
      \end{block}
      \begin{block}{xerces}
        Xerces-C XML DOM wrappers
      \end{block}
      \begin{block}{xml}
        OME XML model and metadata
      \end{block}
      \begin{block}{bioformats}
        Bio-Formats reader and writer interfaces and implementations
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Configuring and building with \texttt{cmake}}
\begin{block}{Configure}
  \begin{semiverbatim}\footnotesize
% mkdir /tmp/bioformats-build
% cd /tmp/bioformats-build
% cmake ~/code/bioformats
\end{semiverbatim}
\end{block}
\begin{block}{Build}
  \begin{semiverbatim}\footnotesize
% make -j8
\end{semiverbatim}
\end{block}
\begin{block}{Install}
  \begin{semiverbatim}\footnotesize
% make DESTDIR=/tmp/bioformats-install install
\end{semiverbatim}
\end{block}
The build directory is separate from the source directory.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Configuring and building with \texttt{cmake}}
\begin{block}{Installed directories}
  \begin{semiverbatim}\tiny
/tmp/bioformats-install
└── usr
    └── local
        ├── include
        │   └── ome
        │       ├── bioformats
        │       ├── compat
        │       ├── xerces
        │       │   └── dom
        │       └── xml
        │           ├── meta
        │           └── model
        │               ├── enums
        │               └── primitives
        └── lib
            └── x86_64-linux-gnu
                └── cmake
\end{semiverbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Configuring and building with \texttt{cmake}}
\begin{block}{Installed libraries}
  \begin{semiverbatim}\scriptsize
/tmp/bioformats-install/usr/local/lib
└── x86_64-linux-gnu
    ├── cmake
    │   ├── ome-bioformats-config.cmake
    │   ├── ome-xerces-config.cmake
    │   └── ome-xml-config.cmake
    ├── libome-bioformats.so -> libome-bioformats.so.5.1.0
    ├── libome-bioformats.so.5.1.0
    ├── libome-xerces.so -> libome-xerces.so.5.1.0
    ├── libome-xerces.so.5.1.0
    ├── libome-xml.so -> libome-xml.so.5.1.0
    └── libome-xml.so.5.1.0
\end{semiverbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Reference}
\begin{block}{Doxygen}
  \begin{itemize}
  \item Doxygen is used to document all APIs
    \item \url{http://ci.openmicroscopy.org/view/5.1/job/BIOFORMATS-5.1-latest-cpp/doxygen/annotated.html}
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Completed functionality}
  \begin{itemize}
  \item \texttt{cmake} build infrastructure
  \item Platform compatibility infrastructure
  \item \texttt{gtest} test framework
  \item Xerces-C wrapper classes
  \item \texttt{xsd-fu} C++ type handling and template conversion
  \item OME-XML model objects and metadata stores
  \item Core Bio-Formats interfaces and supporting classes
  \item Linux and MacOS jenkins build infrastructure
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{TODO}
  \begin{itemize}
  \item Bio-Formats TIFF reader and writer
  \item Bio-Formats OME-TIFF reader and writer
  \item Bio-Formats OME-XML reader and writer
  \item \texttt{showinf} and \texttt{bfconvert} equivalents
  \item Comprehensive test cases
  \item Windows jenkins build infrastructure
  \item (Potential) Refactoring of the Java and C++ model and metadata code, and
    some of the \texttt{FormatReader} and \texttt{FormatWriter}
    interfaces
  \end{itemize}
\end{frame}

\section*{Acknowledgements}

\frame{
  \frametitle{Acknowledgements}
  \parbox[t]{0.45\textwidth}{
    \begin{itemize}
    \item OME Team, Dundee
      \begin{itemize}
      \item Jason Swedlow
      \item Jean-Marie Burel
      \item Mark Carroll
      \item Andrew Patterson
      \item …and the rest of the team
      \end{itemize}
    \end{itemize}
  }
  \parbox[t]{0.45\textwidth}{
    \begin{itemize}
    \item Micron, Oxford
      \begin{itemize}
      \item Douglas Russell
      \end{itemize}
    \item Glencoe Software
      \begin{itemize}
      \item Melissa Linkert
      \item Josh Moore
      \end{itemize}
    \end{itemize}
  }

  \begin{center}
    \vcenteredhbox{\includegraphics[width=0.25\textwidth]{ome}} \hfill
    \vcenteredhbox{\includegraphics[width=0.2\textwidth]{dundee}}\hfill
    \vcenteredhbox{\includegraphics[width=0.5\textwidth]{wellcome}}
  \end{center}
}

\end{document}
