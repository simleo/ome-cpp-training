\documentclass{beamer}

\usepackage{beamerthemesplit}
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}[page number]{}

\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{setspace}

\usepackage{fontspec}
\setmonofont{DejaVu Sans Mono}
\setsansfont{TeX Gyre Heros}

\lstset{breakatwhitespace=true,
language=C++,
basicstyle=\footnotesize\ttfamily,
keywordstyle=\color{blue}\ttfamily,
stringstyle=\color{red}\ttfamily,
commentstyle=\color{brown}\ttfamily,
morecomment=[l][\color{magenta}]{\#}keepspaces=true,
breaklines=true,
tabsize=3,
showstringspaces=false,
extendedchars=true,
frame=single}

\newcommand*{\vcenteredhbox}[1]{\begingroup
\setbox0=\hbox{#1}\parbox{\wd0}{\box0}\endgroup}

\title{Bio-Formats C++ Conversion}
\author{Roger Leigh}
\date{March 2014\\University of Dundee}

\begin{document}

\begin{frame}[plain]
  \titlepage
  \begin{center}
    \vcenteredhbox{\includegraphics[width=0.25\textwidth]{ome}} \hfill
    \vcenteredhbox{\includegraphics[width=0.2\textwidth]{dundee}}\hfill
    \vcenteredhbox{\includegraphics[width=0.25\textwidth]{wellcome}}
  \end{center}
\end{frame}

\section*{Overview}
\frame{
\frametitle{Overview}
\tableofcontents
}

\section{C++ and Java incompatibity}
\subsection{C++ and Java types}

\begin{frame}[fragile]
  \frametitle{Java types}
  \begin{lstlisting}[language=Java]
int i;
double d;

Foo foo = new Foo();

Foo[] a = new Foo[5];
\end{lstlisting}
  \begin{itemize}
  \item Primitive types
  \item Classes, all derived from root \texttt{Object}
  \item No unsigned integer types
  \item Objects are by reference only
  \item Objects and arrays are always allocated with \texttt{new}
  \item Destruction is non-deterministic
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ types}
  \begin{lstlisting}
uint32_t i;
double d;

Foo foo;
Foo *fooptr = new Foo();
const Foo *fooptr2 = &foo;
Foo& fooref(foo);

Foo a[5];
\end{lstlisting}
  \begin{itemize}
  \item Primitive types, including unsigned, of standard sizes
  \item Classes have no common root
  \item All types may be instances, pointers or references
  \item Pointers and references may refer to \texttt{const} type
  \item Pointers may be \texttt{const}
  \item Destruction is deterministic
  \end{itemize}
\end{frame}

\subsection{Reference handling}

\begin{frame}[fragile]
  \frametitle{C++ pointers: pitfalls}
  \begin{lstlisting}
{
  Image *i = new Image(filename);

  i->read_plane(); // throws exception

  // Memory leaked here
  // Memory not freed when pointer i goes out of scope
}
\end{lstlisting}
  \begin{itemize}
    \item \texttt{new} and \texttt{delete} must always be paired
    \item Requires manual management of ownership and lifetime
    \item Bare pointers are not exception-safe
    \item Need to clean up for every exit point in a function
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ pointers: safe “smart” pointers}
  \begin{lstlisting}
{ // Image *i = new Image(filename);
  std::shared_ptr<Image> i(std::make_shared<Image>(filename));

  i->read_plane(); // throws exception

  // Memory freed when i's destructor is
  // run at exit of block scope
}

\end{lstlisting}
  \begin{itemize}
    \item \texttt{shared\_ptr} object lifetime manages the resource
    \item May be used as class members; lifetime is tied to class instance
    \item Clean up for all exit points is automatic and safe
    \item Allows ownership transfer and sharing
    \item Allows reference without ownership using \texttt{weak\_ptr}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RAII: Resource Acquisition Is Initialisation}
    \begin{itemize}
    \item Resource is acquired when object is intialised
    \item Resource is released when object is destroyed
    \item C++ language and runtime guarantees make resource management
      deterministic and reliable
    \item Can manage any resource (memory, files, locks)
    \item Safe for use in any scope
    \item Exception safe
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ reference variants}
  \begin{lstlisting}[basicstyle=\tiny\ttfamily]
//          Non-constant                              Constant
// -----------------------------       ---------------------------------------
// Pointer
                       Image *i;                               const Image *i;
                Image * const i;                        const Image * const i;

// Reference
                       Image& i;                               const Image& i;

// Shared pointer
       std::shared_ptr<Image> i;               std::shared_ptr<const Image> i;
 const std::shared_ptr<Image> i;         const std::shared_ptr<const Image> i;

// Shared pointer reference
      std::shared_ptr<Image>& i;              std::shared_ptr<const Image>& i;
const std::shared_ptr<Image>& i;        const std::shared_ptr<const Image>& i;

// Weak pointer
         std::weak_ptr<Image> i;                 std::weak_ptr<const Image> i;
   const std::weak_ptr<Image> i;           const std::weak_ptr<const Image> i;

// Weak pointer reference
        std::weak_ptr<Image>& i;                std::weak_ptr<const Image>& i;
  const std::weak_ptr<Image>& i;          const std::weak_ptr<const Image>& i;
\end{lstlisting}
\begin{center}
  Java has one reference type.  Here, we have 22.
\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{C++ reference usage rationalised}
\begin{block}{Class members}
  \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
Image i;                     // Concrete instance
std::shared_ptr<Image> i;    // Reference
std::weak_ptr<Image> i;      // Weak reference
\end{lstlisting}
\end{block}
\begin{block}{Arguments}
  \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
void read_plane(const Image& image);
void read_plane(const std::shared_ptr<Image>& image);
\end{lstlisting}
\end{block}
\begin{block}{Return}
  \begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
                  Image get_image(); // ownership transferred
                 Image& get_image(); // ownership retained
 std::shared_ptr<Image> get_image(); // ownership shared/trans
std::shared_ptr<Image>& get_image(); // ownership shared
\end{lstlisting}
\end{block}
\end{frame}

\subsection{Additional API concerns}

\begin{frame}[fragile]
  \frametitle{Safe array passing}
  \begin{lstlisting}
class Image
{
  // Unsafe; size unknown
  uint8_t[] getLUT();
       void setLUT(uint8_t[]& lut);

  // Safe; size defined
  typedef std::array<uint8_t, 256> LUT;
  const LUT& getLUT() const;
        void setLUT(const LUT&);
}
\end{lstlisting}
  \begin{itemize}
  \item C/C++ arrays essentially decay to plain pointers
  \item Plain pointers have no associated size information
  \item \texttt{std::array} is an array-like object
  \item \texttt{std::array} size defined in the template
  \item \texttt{std::array} can be passed like any object
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Containers storing different types}
\begin{block}{Types with a common base}
  \begin{lstlisting}
    std::vector<std::shared_ptr<Base> > v;
    v.push_back(derived1);
    v.push_back(std::make_shared<Derived2>());
\end{lstlisting}
  \begin{itemize}
  \item Stores any type derived from \texttt{Base}
  \end{itemize}
\end{block}
\begin{block}{Types with no common base}
  \begin{lstlisting}
    typedef boost::variant<int, std::string> variants;
    std::vector<variants> v;
    v.push_back(43);
    v.push_back("ATTO 647N")
\end{lstlisting}
  \begin{itemize}
  \item Stores a discriminated set of types
  \item Used to store original metadata
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Containers storing different types}
\begin{block}{Arbitrary types}
  \begin{lstlisting}
    std::vector<boost::any> v;
    v.push_back(Anything);
\end{lstlisting}
  \begin{itemize}
  \item Flexible, but unless you can \texttt{dynamic\_cast} each type,
    you won't be able to handle all stored items.
  \item Not currently used
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interfaces}
\begin{block}{Java}
  Single inheritance, plus interfaces
\end{block}
\begin{block}{C++}
  \begin{itemize}
  \item Multiple inheritance
  \item Interfaces are classes with:
    \begin{itemize}
      \item No instance variables
      \item Pure virtual methods
      \item \texttt{protected} default constructor
      \item \texttt{virtual} destructor
      \item Deleted copy constructor and assignment operator
    \end{itemize}
  \item Classes implementing interfaces:
    \begin{itemize}
      \item Use \texttt{public} inheritance for parent classes
      \item Use \texttt{virtual public} inheritance for implemented interfaces
    \end{itemize}
  \end{itemize}
\end{block}
\end{frame}

\section{Bio-Formats}
\subsection{Building and installing}

\begin{frame}[fragile]
  \frametitle{Source layout}
  \begin{columns}
    \begin{column}{.5\linewidth}
      \begin{semiverbatim}\tiny
cpp
├── cmake
├── lib
│   └── ome
│       ├── bioformats
│       │   └── detail
│       ├── compat
│       ├── internal
│       ├── xerces
│       │   └── dom
│       └── xml
│           ├── meta
│           └── model
│               ├── enums
│               └── primitives
└── test
    ├── ome-bioformats
    ├── ome-compat
    ├── ome-internal
    ├── ome-xerces
    └── ome-xml
\end{semiverbatim}
      \end{column}
    \begin{column}{.5\linewidth}
      \begin{block}{compat}
        Compatibility workarounds
      \end{block}
      \begin{block}{internal}
        Private implementation details
      \end{block}
      \begin{block}{xerces}
        Xerces-C DOM wrappers
      \end{block}
      \begin{block}{xml}
        OME XML model and metadata
      \end{block}
      \begin{block}{bioformats}
        Bio-Formats reader and writer interfaces and implementations
      \end{block}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Configuring and building with \texttt{cmake}}
\begin{block}{Configure}
  \begin{semiverbatim}\footnotesize
% mkdir /tmp/bioformats-build
% cd /tmp/bioformats-build
% GTEST_ROOT=/path/to/gtest cmake ~/code/bioformats
\end{semiverbatim}
\end{block}
\begin{block}{Build}
  \begin{semiverbatim}\footnotesize
% make -j8
\end{semiverbatim}
\end{block}
\begin{block}{Install}
  \begin{semiverbatim}\footnotesize
% make DESTDIR=/tmp/bioformats-install install
\end{semiverbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Configuring and building with \texttt{cmake}}
\begin{block}{Installed directories}
  \begin{semiverbatim}\tiny
/tmp/bioformats-install
└── usr
    └── local
        ├── include
        │   └── ome
        │       ├── bioformats
        │       ├── compat
        │       ├── xerces
        │       │   └── dom
        │       └── xml
        │           ├── meta
        │           └── model
        │               ├── enums
        │               └── primitives
        └── lib
            └── x86_64-linux-gnu
                └── cmake
\end{semiverbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Configuring and building with \texttt{cmake}}
\begin{block}{Installed libraries}
  \begin{semiverbatim}\scriptsize
/tmp/bioformats-install/usr/local/lib
└── x86_64-linux-gnu
    ├── cmake
    │   ├── ome-bioformats-config.cmake
    │   ├── ome-xerces-config.cmake
    │   └── ome-xml-config.cmake
    ├── libome-bioformats.so -> libome-bioformats.so.5.1.0
    ├── libome-bioformats.so.5.1.0
    ├── libome-xerces.so -> libome-xerces.so.5.1.0
    ├── libome-xerces.so.5.1.0
    ├── libome-xml.so -> libome-xml.so.5.1.0
    └── libome-xml.so.5.1.0
\end{semiverbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Reference}
\begin{block}{Doxygen}
  \begin{itemize}
  \item Doxygen is used to document all APIs
    \item \url{http://ci.openmicroscopy.org/view/5.1/job/BIOFORMATS-5.1-latest-cpp/doxygen/annotated.html}
  \end{itemize}
\end{block}
\end{frame}

\section{Acknowledgements}

\frame{
  \frametitle{Acknowledgements}
  \parbox[t]{0.45\textwidth}{
    \begin{itemize}
    \item OME Team, Dundee
      \begin{itemize}
      \item Jason Swedlow
      \item Jean-Marie Burel
      \item Mark Carroll
      \item Andrew Patterson
      \item …and the rest of the team
      \end{itemize}
    \end{itemize}
  }
  \parbox[t]{0.45\textwidth}{
    \begin{itemize}
    \item Micron, Oxford
      \begin{itemize}
      \item Douglas Russell
      \end{itemize}
    \item Glencoe Software
      \begin{itemize}
      \item Melissa Linkert
      \item Josh Moore
      \end{itemize}
    \end{itemize}
  }

  \begin{center}
    \vcenteredhbox{\includegraphics[width=0.25\textwidth]{ome}} \hfill
    \vcenteredhbox{\includegraphics[width=0.2\textwidth]{dundee}}\hfill
    \vcenteredhbox{\includegraphics[width=0.4\textwidth]{wellcome}}
  \end{center}
}

\end{document}
